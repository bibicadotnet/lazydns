//! DNS plugins collection
//!
//! This module contains concrete implementations of DNS plugins.
//! Each plugin implements the Plugin trait and provides specific
//! DNS query processing functionality.
//!
//! # Available Plugins
//!
//! - **forward**: Forward queries to upstream DNS servers
//! - **cache**: Cache DNS responses with TTL-based expiration and LRU eviction
//! - **hosts**: Resolve from local hosts file mappings
//! - **domain_matcher**: Match domains against patterns with wildcard support
//! - **ip_matcher**: Match response IPs against CIDR ranges
//! - **geoip**: Geographic IP address matching
//! - **geosite**: Geographic domain name matching
//! - **advanced**: Upstream control/utility plugins (TTL rewrite, blackhole, etc.)
//!
//! # Example
//!
//! ```rust,no_run
//! use lazydns::plugins::ForwardPlugin;
//! use lazydns::plugin::{Plugin, Context};
//! use std::sync::Arc;
//!
//! # async fn example() -> Result<(), Box<dyn std::error::Error>> {
//! let plugin = ForwardPlugin::new(vec!["8.8.8.8:53".to_string()]);
//! let plugin: Arc<dyn Plugin> = Arc::new(plugin);
//! # Ok(())
//! # }
//! ```

pub mod acl;
pub mod dataset;
pub mod domain_matcher;
pub mod executable;
pub mod flow;
pub mod forward;
pub mod geoip;
pub mod geosite;
pub mod hosts;
pub mod ip_matcher;
pub mod mark;
pub mod matcher;
pub mod server;
// utils module moved to crate-level `src/utils.rs`

// Re-export plugins
pub use acl::{AclAction, QueryAclPlugin};
pub use dataset::{DomainSetPlugin, IpSetPlugin};
pub use domain_matcher::DomainMatcherPlugin;
pub use flow::{
    AcceptPlugin, GotoPlugin, IfPlugin, JumpPlugin, ParallelPlugin, PreferIpv4Plugin,
    PreferIpv6Plugin, RejectPlugin, ReturnPlugin,
};
pub use forward::LoadBalanceStrategy;
pub use geoip::GeoIpPlugin;
pub use geosite::GeoSitePlugin;
pub use ip_matcher::IpMatcherPlugin;
pub use mark::MarkPlugin;

// Re-export matcher plugins
pub use matcher::{
    BaseIntMatcherPlugin, ClientIpMatcherPlugin, CnameMatcherPlugin, EnvMatcherPlugin,
    HasRespPlugin, HasWantedAnsMatcherPlugin, IntComparison, PtrIpMatcherPlugin,
    QClassMatcherPlugin, QNameMatcherPlugin, QTypeMatcherPlugin, RCodeMatcherPlugin,
    RandomMatcherPlugin, StringExpMatcherPlugin, StringExpression,
};

// Re-export executable plugins
pub use executable::{
    ArbitraryPlugin, BlackholePlugin, CachePlugin, DebugPrintPlugin, DropRespPlugin,
    DualSelectorPlugin, Edns0Option, FallbackPlugin, ForwardEdns0OptPlugin, ForwardPlugin,
    HostsPlugin, IpPreference, NftSetPlugin, QuerySummaryPlugin, RateLimitPlugin, RedirectPlugin,
    ReverseLookupPlugin, RosAddrlistPlugin, SequencePlugin, SequenceStep, SleepPlugin, TtlPlugin,
};

// Re-export server plugins
pub use server::{TcpServerPlugin, UdpServerPlugin};

/// Initialize all plugin factories
///
/// This function ensures that all plugin factory registrations are triggered.
/// It should be called early in program initialization, before any plugins
/// are created from configuration.
///
/// The function works by accessing lazy_static variables in each plugin module
/// that contain the factory registration code. This triggers the initialization
/// of those statics, which in turn registers the factories.
///
/// # Example
///
/// ```rust
/// use lazydns::plugins::initialize_all_builders;
///
/// // Initialize plugin builders before loading config
/// initialize_all_builders();
/// ```
pub fn initialize_all_builders() {
    use once_cell::sync::OnceCell;

    static INIT: OnceCell<()> = OnceCell::new();

    INIT.get_or_init(|| {
        use once_cell::sync::Lazy;

        // Force initialization by accessing the Lazy statics generated by register_plugin_builder! macro
        // Note: Macro generates names like CACHE_PLUGIN_BUILDER from CachePlugin
        Lazy::force(&executable::cache::CACHE_PLUGIN_BUILDER);
        Lazy::force(&executable::forward::FORWARD_PLUGIN_BUILDER);
        Lazy::force(&flow::accept::ACCEPT_PLUGIN_BUILDER);
        Lazy::force(&flow::reject::REJECT_PLUGIN_BUILDER);
        Lazy::force(&flow::return_plugin::RETURN_PLUGIN_BUILDER);
        Lazy::force(&flow::jump::JUMP_PLUGIN_BUILDER);
        Lazy::force(&flow::prefer_ipv4::PREFER_IPV4_PLUGIN_BUILDER);
        Lazy::force(&flow::prefer_ipv6::PREFER_IPV6_PLUGIN_BUILDER);
        Lazy::force(&executable::drop_resp::DROP_RESP_PLUGIN_BUILDER);
        Lazy::force(&dataset::domain_set::DOMAIN_SET_PLUGIN_BUILDER);
        Lazy::force(&dataset::ip_set::IP_SET_PLUGIN_BUILDER);
        Lazy::force(&executable::hosts::HOSTS_PLUGIN_BUILDER);
        Lazy::force(&executable::ros_addrlist::ROS_ADDRLIST_PLUGIN_BUILDER);
        Lazy::force(&executable::ttl::TTL_PLUGIN_BUILDER);
        Lazy::force(&executable::black_hole::BLACKHOLE_PLUGIN_BUILDER);
        Lazy::force(&executable::redirect::REDIRECT_PLUGIN_BUILDER);
        // Lazy::force(&executable::sequence::SEQUENCE_PLUGIN_BUILDER);
        Lazy::force(&executable::fallback::FALLBACK_PLUGIN_BUILDER);
        Lazy::force(&matcher::has_resp::HAS_RESP_PLUGIN_BUILDER);
        Lazy::force(&server::UDP_SERVER_PLUGIN_BUILDER);
        Lazy::force(&server::TCP_SERVER_PLUGIN_BUILDER);
        Lazy::force(&executable::ratelimit::RATE_LIMIT_PLUGIN_BUILDER);

        // Initialize the builder system
        crate::plugin::builder::initialize();

        let count = crate::plugin::builder::get_all_plugin_types().len();
        if count > 0 {
            tracing::info!("Initialized {} plugin builders", count);
        }
    });
}

// Re-add tests module at file end to satisfy lints
#[cfg(test)]
mod tests {
    use super::*;
    use crate::plugin::Plugin;
    use std::sync::Arc;

    #[test]
    fn test_forward_plugin_accessible() {
        // Verify ForwardPlugin can be created
        let plugin = ForwardPlugin::new(vec!["8.8.8.8:53".to_string()]);
        assert_eq!(plugin.name(), "forward");
    }

    #[test]
    fn test_cache_plugin_accessible() {
        // Verify CachePlugin can be created
        let plugin = CachePlugin::new(100);
        assert_eq!(plugin.name(), "cache");
    }

    #[test]
    fn test_hosts_plugin_accessible() {
        // Verify HostsPlugin can be created
        let plugin = HostsPlugin::new();
        assert_eq!(plugin.name(), "hosts");
    }

    #[test]
    fn test_domain_matcher_plugin_accessible() {
        // Verify DomainMatcherPlugin can be created
        let plugin = DomainMatcherPlugin::new("match_key");
        assert_eq!(plugin.name(), "domain_matcher");
    }

    #[test]
    fn test_ip_matcher_plugin_accessible() {
        // Verify IpMatcherPlugin can be created
        let plugin = IpMatcherPlugin::new("match_key");
        assert_eq!(plugin.name(), "ip_matcher");
    }

    #[test]
    fn test_ratelimit_plugin_accessible() {
        // Verify RateLimitPlugin can be created
        let plugin = RateLimitPlugin::new(10, 60);
        assert_eq!(plugin.name(), "rate_limit"); // Note: actual name is "rate_limit" with underscore
    }

    #[test]
    fn test_advanced_plugins_accessible() {
        // Verify advanced plugin types are accessible
        // BlackholePlugin is implemented in `plugins::executable::black_hole` and
        // provides `new_from_strs` constructor.
        let _blackhole = BlackholePlugin::new_from_strs(Vec::<&str>::new()).unwrap();
        let _ttl = TtlPlugin::new(300, 0, 0);
        let _return = ReturnPlugin::new();
    }

    #[test]
    fn test_load_balance_strategy() {
        // Verify LoadBalanceStrategy enum is accessible
        let _rr = LoadBalanceStrategy::RoundRobin;
        let _random = LoadBalanceStrategy::Random;
        let _fastest = LoadBalanceStrategy::Fastest;

        assert_eq!(
            LoadBalanceStrategy::RoundRobin,
            LoadBalanceStrategy::RoundRobin
        );
    }

    #[test]
    fn test_acl_action() {
        // Verify AclAction enum is accessible
        let _allow = AclAction::Allow;
        let _deny = AclAction::Deny;
    }

    #[test]
    fn test_plugins_implement_trait() {
        // Verify plugins can be used as trait objects
        let forward: Arc<dyn Plugin> = Arc::new(ForwardPlugin::new(vec!["8.8.8.8:53".to_string()]));
        let cache: Arc<dyn Plugin> = Arc::new(CachePlugin::new(100));
        let hosts: Arc<dyn Plugin> = Arc::new(HostsPlugin::new());

        assert_eq!(forward.name(), "forward");
        assert_eq!(cache.name(), "cache");
        assert_eq!(hosts.name(), "hosts");
    }
}
